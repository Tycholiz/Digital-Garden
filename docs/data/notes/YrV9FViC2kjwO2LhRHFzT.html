<h1 id="graphql-documents">Graphql Documents<a aria-hidden="true" class="anchor-heading icon-link" href="#graphql-documents"></a></h1>
<p>There is a distinction between Graphql Documents and Operations:</p>
<ul>
<li>An operation is a <a href="/notes/gGzeOuPukb4NWrzp19nTh">query</a>, <a href="/notes/4IVBdBVIxZ8v6ft1pnsxx">mutation</a>, or <a href="/notes/4s9zBnlRCUfaKpfVTyzkV">subscription</a></li>
<li>A document is one or more operation (including any <a href="/notes/rTh8o3bHYboRrs5AOdTZV">fragments</a>) stringified in a request body.</li>
</ul>
<p><code>query</code> types and <code>mutation</code> types are the entry point to a graphql query</p>
<ul>
<li>It's important to remember that other than the special status of being the "entry point" into the schema, the Query and Mutation types are the same as any other GraphQL object type, and their fields work exactly the same way.</li>
</ul>
<p>Every GraphQL query has the shape of a tree â€” i.e. it is never circular. </p>
<p>Scalars are primitive values in GraphQL. If we consider a graphql query as a hierarchical graph, the leaves would be the primitives</p>
<p>GraphQL requires that you construct your queries in a way that only returns concrete data</p>
<ul>
<li>Each field has to ultimately resolve to one or more scalars (or enums). That means you cannot just request a field that resolves to a type without also indicating which fields of that type you want to get back (hence why <code>graphiql</code> will auto-complete for us).</li>
</ul>
<p>two operations that occur in GraphQL servers are:</p>
<ol>
<li><strong>result coercion</strong>: upholding the contract of a type which we receive from the server (basically upholding the primitive values or object type)
<ul>
<li>The type system knows what to expect and will convert the values returned by a resolver function into something that upholds the API contract</li>
</ul>
</li>
<li><strong>input coercion</strong>: upholding the contract of a type for input arguments that we pass into the GraphQL query or mutation
<ul>
<li>if we pass in <code>5</code> for the <code>id</code> field, the type will be parsed into a string as <code>"5"</code></li>
</ul>
</li>
</ol>
<h3 id="arguments">Arguments<a aria-hidden="true" class="anchor-heading icon-link" href="#arguments"></a></h3>
<p>In REST, there is one place to pass arguments, which is in query params or in the request body. With Graphql, every field and nested object can get its own set of arguments.</p>
<ul>
<li>declarative data fetching where a client can specify exactly what data it needs from an API. Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.</li>
<li>The <code>GraphQLSchema</code> object is the core of a GraphQL server
<ul>
<li><code>GraphQLSchema</code> consists of 2 parts:
<ol>
<li>schema definition (ie. the structure)</li>
<li>resolver functions that implement the API (ie. the behaviour)</li>
</ol>
</li>
<li>Query and Mutate are the rootTypes</li>
</ul>
</li>
<li>Graphql is completely agnostic to the network layer (usually HTTP) and payload format (normally JSON). In fact, Graphql is not opinionated about the application architecture in general.</li>
<li>Graphql allows us to make relational queries that allow us to get all the data needed in one trip, instead of having to make multiple calls.</li>
</ul>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/notes/rTh8o3bHYboRrs5AOdTZV">Fragments</a></li>
<li><a href="/notes/4IVBdBVIxZ8v6ft1pnsxx">Mutations</a></li>
<li><a href="/notes/gGzeOuPukb4NWrzp19nTh">Queries</a></li>
<li><a href="/notes/4s9zBnlRCUfaKpfVTyzkV">Subscriptions</a></li>
</ol>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/CSePBQ6q7qhowKESqVwt7">Graphql</a></li>
</ul>