<h1 id="isolation">Isolation<a aria-hidden="true" class="anchor-heading icon-link" href="#isolation"></a></h1>
<p>Isolation determines the extent to which items involved in a single <a href="/notes/4xb9cg487yio88c5b2j2bid">transaction</a> are visible to everything outside the transaction.</p>
<ul>
<li>a lower isolation level increases the ability of many users to access the same data at the same time, but increases the number of concurrency effects (such as dirty reads or lost updates) users might encounter. </li>
<li>a higher isolation level reduces the types of concurrency effects that users may encounter, but requires more system resources and increases the chances that one transaction will block another.</li>
</ul>
<p>Isolation is the idea that if we have multiple things to do in a single transaction, we can roll it back as a chunk.</p>
<ul>
<li>Imagine a transaction consists of 2 inserts and 1 update. The fact that we have atomicity means that we can rollback that whole transaction. This distinction is even more important when you consider multi-table transactions, which MongoDB does not offer.</li>
<li>ex. In old versions of MongoDB if you needed to remove an item from inventory and add it to someone's order at the same time, you could not.</li>
<li>ex. in multi-threaded programming, if one thread executes an atomic operation, that means there is no way that another thread could see the half-finished result of the operation. The system can only be in the state it was before the operation or after the operation, not something in between.
A transaction in process and not yet committed must remain isolated from any other transaction.</li>
</ul>
<p>Isolation is about having multiple <a href="/notes/W5etsXYnFDHBWHEHSZKjp">concurrently</a> executing transactions that are isolated from each other.</p>
<ul>
<li>The database ensures that when the transactions have committed, the result is the same as if they had run <em>serially</em> (one after another), even though in reality they may have run concurrently</li>
</ul>
<p>Isolation is the opposite side of atomicity.</p>
<ul>
<li>while we are doing our queries, are we allowed to see what is happening concurrently in the rest of the system?
<ul>
<li>ex. what if we want to make a backup with <code>pg_dump</code> that needs to run for several hours? That backup needs to be a consistent snapshot of the production database. If during the backup someone is doing inserts, we don't want these to be in the backup, since we want a snapshot that doesn't move.		- to do this, postgres uses an isolation mode that prevents this from happening.	</li>
</ul>
</li>
</ul>
<p>isolation can be implemented using a lock on each object (allowing only one thread to access an object at any one time)</p>
<p>In theory, isolation should make your life easier by letting you pretend that no concurrency is happening.</p>
<h2 id="levels-of-isolation">Levels of isolation<a aria-hidden="true" class="anchor-heading icon-link" href="#levels-of-isolation"></a></h2>
<p>By increasing levels of isolation, we are able to prevent some race conditions from happening.</p>
<p>Higher levels of isolation come with a performance cost that in most cases aren't worth it. It’s therefore common for systems to use weaker levels of isolation, which protect against some concurrency issues, but not all. </p>
<h3 id="read-committed">Read committed<a aria-hidden="true" class="anchor-heading icon-link" href="#read-committed"></a></h3>
<p>This is the most basic level of transaction isolation.</p>
<p>It makes two guarantees:</p>
<ol>
<li>When reading from the database, you will only see data that has been committed (no dirty reads).
<ul>
<li>if a transaction has written some data to the database, but the transaction has not yet committed or aborted, and another transaction can see that uncommitted data, that is called a <em>dirty read</em>.</li>
</ul>
</li>
<li>When writing to the database, you will only overwrite data that has been committed (no dirty writes).
<ul>
<li>if 2 transactions concurrently try to update the same object in a database, and second write overwrites an uncommitted value from the first write, that is called a <em>dirty write</em>. To prevent this, the second write must be delayed until the first transaction has completed.</li>
<li>databases prevent dirty writes by using row-level locks: when a transaction wants to modify a particular object (row or document), it must first acquire a lock on that object, and must only release it when the transaction has completed. </li>
</ul>
</li>
</ol>
<p>Read committed isolation does not prevent race conditions occurring when 2 different users are trying to increment the same counter simultaneously.</p>
<p>Read committed is a popular isolation level, and is the default setting in Postgres.</p>
<h3 id="snapshot-isolation">Snapshot isolation<a aria-hidden="true" class="anchor-heading icon-link" href="#snapshot-isolation"></a></h3>
<p>Snapshot isolation is a guarantee that all reads made in a transaction will see a consistent snapshot of the database, and the transaction itself will successfully commit only if no updates it has made conflict with any concurrent updates made since that snapshot.</p>
<ul>
<li>in practice it reads the values resulting from the last committed transaction that existed at the time it started</li>
</ul>
<p>Snapshot isolation has the mantra "readers never block writers, and writers never block readers".</p>
<p>The idea is that each transaction reads from a consistent snapshot of the database— that is, the transaction sees all the data that was committed in the database at the start of the transaction. Even if the data is subsequently changed by another transaction, each transaction sees only the old data from that particular point in time.</p>
<ul>
<li>snapshot isolation is therefore considered necessary for long-running, read-only queries such as backups and analytics. </li>
</ul>
<p>Allows better performance than serializability, yet still avoids most of the concurrency anomalies that serializability avoids.</p>
<p>implementations of snapshot isolation typically use write locks to prevent dirty writes</p>
<p>From a performance point of view, a key principle of snapshot isolation is readers never block writers, and writers never block readers. </p>
<ul>
<li>therefore, reads do not require any locks.</li>
</ul>
<p>Because it maintains several versions of an object side by side, this technique is known as multiversion concurrency control (MVCC).</p>
<p>Snapshot isolation is usually implemented by <a href="/notes/Mzsmv3XQV978L3jm2eumP">MVCC</a>.</p>
<p>used by Postgres (called <em>repeatable read</em>), Mongo, MySQL</p>
<h3 id="serializability">Serializability<a aria-hidden="true" class="anchor-heading icon-link" href="#serializability"></a></h3>
<p>Serializable isolation means that the database guarantees that transactions have the same effect as if they ran serially (i.e., one at a time, without any concurrency)</p>
<ul>
<li>by doing this, all possible race conditions are avoided.</li>
</ul>
<p>Serializability means each transaction can pretend that it is the only transaction running on the entire database. </p>
<p>Serializable isolation is rarely used because it carries a performance penalty.</p>
<p>There are 3 principal techniques to implementing serializability:</p>
<ol>
<li>Literally execute transactions in a serial order
<ul>
<li>possible when the entire active dataset can reside in <a href="/notes/siARuFkNsvSlUI0PLbh5E">memory</a></li>
<li>used in <a href="/notes/gWAg15uBJgkS2B0wcpMAa">Redis</a></li>
</ul>
</li>
<li>Two-phase locking</li>
<li>Optimistic concurrency control techniques such as serializable snapshot isolation</li>
</ol>
<p>In Postgres, Serializability is implemented as <em>serializable snapshot isolation</em> (SSI), which provides full serializability, but has only a small performance penalty compared to snapshot isolation. </p>
<ul>
<li>optimistic concurrency control technique. Optimistic in this context means that instead of blocking if something potentially dangerous happens, transactions continue anyway, in the hope that everything will turn out all right. When a transaction wants to commit, the database checks whether anything bad happened (i.e., whether isolation was violated); if so, the transaction is aborted and has to be retried. Only transactions that executed serializably are allowed to commit.</li>
</ul>
<h2 id="strategies">Strategies<a aria-hidden="true" class="anchor-heading icon-link" href="#strategies"></a></h2>
<h3 id="record-locking">Record Locking<a aria-hidden="true" class="anchor-heading icon-link" href="#record-locking"></a></h3>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/kx2pz7bcwpswtpjcsmjlzlj">Race Conditions</a></li>
<li><a href="/notes/Ql1WxSHx11UTkDnfmYlzq">Consistency</a></li>
<li><a href="/notes/Mzsmv3XQV978L3jm2eumP">Concurrency</a></li>
<li><a href="/notes/4xb9cg487yio88c5b2j2bid">Transaction</a></li>
<li><a href="/notes/r9orvg7n574j5bmwon0nb74">Multi-version Concurrency Control (MVCC)</a></li>
</ul>