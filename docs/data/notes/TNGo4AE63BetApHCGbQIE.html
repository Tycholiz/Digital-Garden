<h1 id="this">This<a aria-hidden="true" class="anchor-heading icon-link" href="#this"></a></h1>
<p><code>this</code> only cares about execution context (where the fn was called; ie. call-site). it doesn't care about the scope chain</p>
<p><code>this</code> is essentially an implicit input to a function, thereby negatively impacting function purity. Think of <code>this</code> as an implicit argument that gets passed into the function.</p>
<ul>
<li>ie. because of this impure nature, <code>this</code> shouldn't be used in <a href="/notes/IGAUCRCeWHKzpViYTrx1N">Functional Programming</a></li>
</ul>
<p><code>this</code> is context-bound and not instance-bound. If, for example, a method is passed on as a callback, it loses its context. If the method is then called like a function, the context will be undefined. As such, in order to avoid this scenario, the <code>this</code> context has to be captured in the method. This can be done either by wrapping the method (() => f()), using a field with an arrow function instead (f = () => {}), or using a bound version of it using bind (f = f.bind(<code>this</code>)).</p>
<p>The scope chain encompasses the prototype chain</p>
<ul>
<li>Expl. Imagine 2 functions: inner() and outer(). If a variable is used within inner() and it does not exist within that function's context, it will look at its prototype to see if it exists (prototype chain). If it goes all the way up the chain and still doesn't exist, then the scope of outer() will be considered.</li>
<li>Expl. If this were illustrated as 2 for loops, the scope chain would be the <code>i</code> iterator, while prototype would be <code>j</code></li>
</ul>
<p><code>return</code> is a keyword which returns us to the immediate outer execution context (to continue parsing at the point directly after where the function was called)</p>
<h2 id="classes">Classes<a aria-hidden="true" class="anchor-heading icon-link" href="#classes"></a></h2>
<p>The behavior of <code>this</code> in classes and functions is similar, since classes are functions under the hood. There are some important caveats:</p>
<ul>
<li>methods of a class can be accessed on <code>this</code>.
<ul>
<li>We might assume that this means that the method is a property on the <code>this</code> object. This is a false assumption. The reality is that the method is a property on the class itself (which is the prototype of <code>this</code>). This means that when we are accessing a method like <code>this.moveUnit</code>, the <code>moveUnit</code> is being accessed by traversing this prototype chain, up from <code>this</code> and reaching the class itself, upon which the method is found.</li>
</ul>
</li>
<li>if a method is marked <code>static</code>, then it is not added to the prototype of <code>this</code>.</li>
</ul>
<h2 id="arrow-functions">Arrow functions<a aria-hidden="true" class="anchor-heading icon-link" href="#arrow-functions"></a></h2>
<p>Until arrow functions, every new function defined its own <code>this</code> value (a new object in the case of a constructor, <code>undefined</code> in strict mode function calls, the base object if the function is called as an "object method", etc.). </p>
<ul>
<li>This proved to be less than ideal with an object-oriented style of programming.</li>
</ul>
<p>An arrow function does not have its own <code>this</code>; the <code>this</code> value of the enclosing execution context is used.</p>
<p>In arrow functions, <code>this</code> retains the value of the enclosing lexical context's <code>this</code>, whereas a normal function's <code>this</code> value is whatever the caller's scope is.</p>
<ul>
<li>In global code, it will be set to the global object. Here, the enclosing lexical context (ie. the context of <code>foo</code>) is the global context:</li>
</ul>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> globalObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> globalObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// `true` returned because the function `foo` is in the global scope</span>
</code></pre>
<p>This logic follows that if we had an arrow function within another function, the arrow functions <code>this</code> value would retain the value of the outer functions <code>this</code> object.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> outerFunctionContext <span class="token operator">=</span> <span class="token keyword">this</span>
	<span class="token keyword">const</span> inner <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">this</span><span class="token punctuation">)</span>
	<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>outerFunctionContext <span class="token operator">===</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/ycI4A22oQK4xPHhWZaonw">Functions</a></li>
<li><a href="/notes/HBiP5GIRzCiKzuCXYODmn">useEffect</a></li>
</ul>