<h1 id="sqs-simple-queue-service">SQS (Simple Queue Service)<a aria-hidden="true" class="anchor-heading icon-link" href="#sqs-simple-queue-service"></a></h1>
<p>Highly-durable queue in the cloud</p>
<ul>
<li>put messages on one end, and a consumer takes them out from the other side.</li>
</ul>
<p>Messages are consumed <em>almost</em> in FIFO, but there is no strictness to adhere to this.</p>
<ul>
<li>Strictness <em>can</em> be guaranteed, but there is a performance cost.</li>
</ul>
<p>Queues are an important mechanism for providing fault tolerance in distributed systems.</p>
<ul>
<li>The service durably persists messages until they are processed by a downstream consumer.</li>
</ul>
<p>SQS scales elastically, and there is no limit to the number of messages per queue.</p>
<p>SQS requires zero capacity management.</p>
<ul>
<li>no limit on the rate of messages enqueued or consumed</li>
<li>donâ€™t have to worry about any throttling limits.</li>
<li>number of messages stored in SQS (the backlog size) is also unlimited.</li>
</ul>
<p>great default choice for dispatching asynchronous work.</p>
<h3 id="sqs-vs-sns">SQS vs SNS<a aria-hidden="true" class="anchor-heading icon-link" href="#sqs-vs-sns"></a></h3>
<p>SNS is "heavier":</p>
<ul>
<li>SQS lets any authorized connection read from it, SNS requires a specific subscription. </li>
<li>SQS can be read from a local dev end, SNS will need a local tunnel like ngrok to receive. </li>
<li>By default stuff just waits on SQS, the default SNS behaviour is to immediately send the notification.</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/QukN1H4jrogOyBjotZd7U">AWS Services</a></li>
<li><a href="/notes/3E2oC3PsnDWowLW9hK0eZ">SNS (Simple Notification Service)</a></li>
<li><a href="/notes/OSdV9FvBG3wDbRNLllg0V">AWS Lambda</a></li>
<li><a href="/notes/Skg9BUUhw2xIBmwrkEP4u">Messaging Pattern</a></li>
<li><a href="/notes/Ag4RGxbqigmzcZAUS9FRv">Lambda Function</a></li>
<li><a href="/notes/0pUoWXrTC07Z9B1ijwosK">Dead Letter Queue</a></li>
</ul>