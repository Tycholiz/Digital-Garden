<h1 id="functional"><a aria-hidden="true" class="anchor-heading" href="#functional"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Functional</h1>
<h1 id="overview"><a aria-hidden="true" class="anchor-heading" href="#overview"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Overview</h1>
<p>"function" is a reference to how functions work in math.
Ex. f(x) = 2xÂ² + 5 can be plotted on a graph to make a parabola. In this sense, it can be thought of as a map. An x value of 5 maps to a return value of 55.
Though FP rarely deals with graphs like this, think of it as input values mapping to output
<img src="/Digital-Garden/assets/images/2021-03-09-09-35-55.png"></p>
<p>functional languages are closer to math than the more popular imperative languages.</p>
<p>Based on idea of Referential Transparency</p>
<h3 id="referential-transparency"><a aria-hidden="true" class="anchor-heading" href="#referential-transparency"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Referential transparency</h3>
<p>The notion that a function could be replaced by its return value and it wouldn't impact the functionality of the program.
If satisfied, this is a clear sign that a function is pure.
as you're reading a program, once you've mentally computed what a pure function call's output is, you no longer need to think about what that exact function call is doing when you see it in code, especially if it appears multiple times.
That result becomes kinda like a mental const declaration, which as you're reading you can transparently swap in and not spend any more mental energy working out.</p>
<h2 id="abstracting-generalizing-functions"><a aria-hidden="true" class="anchor-heading" href="#abstracting-generalizing-functions"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Abstracting (Generalizing) Functions</h2>
<p>Similar to how partial application and currying (see Chapter 3) allow a progression from generalized to specialized functions, we can abstract by pulling out the generality between two or more tasks. The general part is defined once, so as to avoid repetition. To perform each task's specialization, the general part is parameterized.</p>
<p>consider:</p>
<pre><code>function saveComment(txt) {
    if (txt != "") {
        comments[comments.length] = txt;
    }
}

function trackEvent(evt) {
    if (evt.name !== undefined) {
        events[evt.name] = evt;
    }
}
</code></pre>
<p>the repetition (generality) between the 2 functions is: storing a value in a data source. the uniqueness (specialty) of them is that one sticks the value on the end of an array, while the other sets the value as a property on an object.</p>
<p>abstracting:</p>
<pre><code>function storeData(store,location,value) {
    store[location] = value;
}

function saveComment(txt) {
    if (txt != "") {
        storeData( comments, comments.length, txt );
    }
}

function trackEvent(evt) {
    if (evt.name !== undefined) {
        storeData( events, evt.name, evt );
    }
}
</code></pre>
<hr>
<h2 id="children"><a aria-hidden="true" class="anchor-heading" href="#children"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Children</h2>
<ol>
<li><a href="/Digital-Garden/notes/670976d5-df19-413a-8563-0433b0f0d707">Currying</a></li>
<li><a href="/Digital-Garden/notes/5d269d8b-3323-4089-9fac-052909343d09">Lens</a></li>
<li><a href="/Digital-Garden/notes/62383843-32b7-4e1d-b2b3-9261ae5800ac">Purity</a></li>
<li><a href="/Digital-Garden/notes/321388fd-fcad-4f32-b902-20c0ee043f9f">Recursion</a></li>
<li><a href="/Digital-Garden/notes/284556b1-3f05-4eb7-a93f-26bcef058391">Transducer</a></li>
</ol>