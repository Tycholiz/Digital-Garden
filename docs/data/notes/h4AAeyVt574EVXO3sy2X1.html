<h1 id="process"><a aria-hidden="true" class="anchor-heading" href="#process"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Process</h1>
<p>since a process is a type of environment, environment variables can be associated with a process.</p>
<ul>
<li>ex. when we say <code>process.env</code> we are talking about getting environment variables that exist during a specific process</li>
</ul>
<p>If a program is a set of instructions to carry out a specific task, then a process is just <strong>a program in execution</strong></p>
<p>a <strong>Signal</strong> is the way that a process can communicate with the OS</p>
<ul>
<li>Signal and interrupt are basically same, but with a small distinction:
<ul>
<li>interrupts are generated by the processor and handled by the kernel</li>
<li>signals are generated by the kernel and handled by the process.</li>
</ul>
</li>
</ul>
<p>Every time a program wants to do something (like process a key press, or open a file, or exit) that program needs to ask its parent to do it for it (the parent is the kernel)</p>
<h1 id="debugging"><a aria-hidden="true" class="anchor-heading" href="#debugging"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Debugging</h1>
<ul>
<li>strace/truss, ltrace and gdb are generally good ideas for looking at why a process is stuck. (truss -u on Solaris is particularly helpful; I find ltrace too often presents arguments to library calls in an unusable format.) Solaris also has useful /proc-based tools, some of which have been ported to Linux. (pstack is often helpful).</li>
</ul>