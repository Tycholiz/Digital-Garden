<h1 id="process">Process<a aria-hidden="true" class="anchor-heading icon-link" href="#process"></a></h1>
<p>Since a process itself forms an environment, <a href="/notes/GRUOiXWhnzYEkI7ZDHMko">environment variables</a> are associated with a single process.</p>
<ul>
<li>ex. when we say <code>process.env</code> we are talking about getting environment variables that exist during a specific process</li>
</ul>
<p>If a program is a set of instructions to carry out a specific task, then a process is just <strong>a program in execution</strong></p>
<p>a <strong>Signal</strong> is the way that a process can communicate with the OS</p>
<ul>
<li>Signal and interrupt are basically same, but with a small distinction:
<ul>
<li>interrupts are generated by the processor and handled by the </li>
<li>signals are generated by the kernel and handled by the process.</li>
</ul>
</li>
</ul>
<p>Every time a program wants to do something (like process a key press, or open a file, or exit) that program needs to ask its parent to do it for it (the parent is the kernel)</p>
<h3 id="how-a-process-comes-to-life">How a process comes to life<a aria-hidden="true" class="anchor-heading icon-link" href="#how-a-process-comes-to-life"></a></h3>
<p>A process comes into existence via actions facilitated by the <a href="/notes/o3pgogrf5w0a9ex1s4bgx7x">kernel scheduler</a>.</p>
<h3 id="how-a-process-requests-service-of-the-kernel">How a process requests service of the kernel<a aria-hidden="true" class="anchor-heading icon-link" href="#how-a-process-requests-service-of-the-kernel"></a></h3>
<p>A process can request the kernel's services by either making a system call or passing a <a href="/notes/Skg9BUUhw2xIBmwrkEP4u">message</a></p>
<ul>
<li>The OS will implement one or the other, but not both.</li>
</ul>
<p>By accessing these services, the process can do things like</p>
<ul>
<li>Accessing hardware related services
<ul>
<li>ex. if Zoom needs to access the Camera, or VSCode needs to access your file system</li>
</ul>
</li>
<li>Spawning new processes</li>
<li>Communicating with integral kernal services, like <a href="/notes/o3pgogrf5w0a9ex1s4bgx7x">scheduling</a></li>
</ul>
<p>These system calls serve as interfaces between a process and the OS.</p>
<p>System calls are analogous to calling REST endpoints. The OS provides a library of user functions, which a process can call.</p>
<p>From the perspective of the application making the system call, it is identical to an ordinary procedure call.</p>
<h1 id="debugging">Debugging<a aria-hidden="true" class="anchor-heading icon-link" href="#debugging"></a></h1>
<ul>
<li><code>strace</code>/<code>truss</code>, <code>ltrace</code> and <code>gdb</code> are generally good ideas for looking at why a process is stuck. (truss -u on Solaris is particularly helpful; I find ltrace too often presents arguments to library calls in an unusable format.) Solaris also has useful /proc-based tools, some of which have been ported to Linux. (pstack is often helpful).</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/LTtn2x9aVBeLPMsiR4H8j">Thread</a></li>
<li><a href="/notes/1j3g1u7kbq5zk7lj1dt1fzk">Abstraction</a></li>
</ul>