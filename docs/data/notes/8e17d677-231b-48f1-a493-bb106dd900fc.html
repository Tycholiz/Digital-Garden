<h1 id="acid"><a aria-hidden="true" class="anchor-heading" href="#acid"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Acid</h1>
<h3 id="how-postgres-handles-transactions-and-concurrency"><a aria-hidden="true" class="anchor-heading" href="#how-postgres-handles-transactions-and-concurrency"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>How Postgres handles Transactions and Concurrency</h3>
<p>Postgres handles these 2 problems with MVCC (multi-version concurrency control)</p>
<ul>
<li>When you update or delete a row, Postgres doesn't actually remove the row. When you do an UPDATE or DELETE, the row isn't actually physically deleted. For a DELETE, the database simply marks the row as unavailable for future transactions, and for UPDATE, under the hood it's a combined INSERT then DELETE, where the previous version of the row is marked unavailable. These new versions of rows are generally referred to as the "live" rows, and the older versions are referred to as "dead" rows.</li>
</ul>
<h2 id="ue-resources"><a aria-hidden="true" class="anchor-heading" href="#ue-resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>UE Resources</h2>
<p><a href="https://www.postgresql.org/docs/current/mvcc-intro.html">Concurrency control</a></p>