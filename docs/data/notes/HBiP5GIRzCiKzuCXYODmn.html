<h1 id="useeffect">useEffect<a aria-hidden="true" class="anchor-heading icon-link" href="#useeffect"></a></h1>
<h2 id="overview">Overview<a aria-hidden="true" class="anchor-heading icon-link" href="#overview"></a></h2>
<p><code>useEffect</code> lets you specify side effects that should be triggered by the rendering of a component, rather than by a particular user-triggered event (like a button click). </p>
<ul>
<li>ex. setting up a connection to a remote server happens once the component renders— not when a user performs some action.</li>
</ul>
<p>You can think of <code>useEffect</code> as "attaching" a piece of behavior to the render output. </p>
<p>The purpose of <code>useEffect</code> is to allow us use an escape hatch from React and synchronize with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved, then we shouldn't need a <code>useEffect</code></p>
<h3 id="relationship-to-closures">Relationship to closures<a aria-hidden="true" class="anchor-heading icon-link" href="#relationship-to-closures"></a></h3>
<p>When you define a function inside the <code>useEffect</code> hook, that function forms a <a href="/notes/YkeDcbKsKFPYr4K4AaxyL">closure</a> over the variables in the component's scope at the time the effect was created.</p>
<ul>
<li>ex. In the following example, the <code>handleClick</code> function forms a closure over the <code>count</code> variable. This means that when <code>handleClick</code> is invoked, it will capture the value of <code>count</code> from the outer scope where the effect was created.</li>
</ul>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">MyComponent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This will capture the count value from the outer scope</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Rest of the component...</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Effects from each render are isolated from each other. This is due to the closure.</p>
<h3 id="when-the-effect-gets-run">When the effect gets run<a aria-hidden="true" class="anchor-heading icon-link" href="#when-the-effect-gets-run"></a></h3>
<p><code>useEffect</code> runs after the JSX has been reconciled and the DOM has been updated.</p>
<ul>
<li>contrast this will all other non-JSX code in a component body which gets run <em>while</em> the component is rendering.
<ul>
<li>For this reason, we must pay especially close attention to component body code that would attempt to modify any DOM elements that are generated by the component's JSX.</li>
<li>This is the value of <code>useEffect</code>. It allows us to wait until a component has finished rendering before we attempt to manipulate any DOM elements</li>
<li>ex. if our <code>App</code> component had a child <code>VideoPlayer</code> component, we would not be able to attach a <a href="/notes/xLeJix4672o4VYu5PYkNp">ref</a> to the <code>&#x3C;video></code> tag and expect to be able to just call <code>ref.current.play()</code> on it. We would have to wrap that code in a <code>useEffect</code>, which would essentially be saying "don't try to access this ref until the component has finished rendering all its JSX (see example <a href="https://react.dev/learn/synchronizing-with-effects#step-2-specify-the-effect-dependencies">here</a>)</li>
</ul>
</li>
</ul>
<p>Keep in mind that <code>useEffect</code> is typically used to "step out" of your React code and synchronize with some external system </p>
<ul>
<li>ex. "external system" might mean browser APIs, third-party widgets, network</li>
</ul>
<p>We should also add a cleanup function (ie. the <code>return</code> code) if needed. Some Effects need to specify how to stop, undo, or clean up whatever they were doing. </p>
<ul>
<li>ex. "connect" needs "disconnect", "subscribe" needs "unsubscribe", and "fetch" needs either "cancel” or "ignore".</li>
</ul>
<p>React always cleans up the previous render’s Effect before the next render’s Effect.</p>
<ul>
<li>that is, if we are in a state where <code>useEffect</code> needs to run again (e.g. a value in the dependency changed), the cleanup will always get run before the next <code>useEffect</code> gets called.</li>
</ul>
<p>In development mode, React remounts the component once to verify that you’ve implemented cleanup well.</p>
<ul>
<li>that is, in a <code>useEffect</code>, the main body will get run once, then the cleanup gets run, then the main body will get run again.</li>
</ul>
<h4 id="dependency-array">Dependency array<a aria-hidden="true" class="anchor-heading icon-link" href="#dependency-array"></a></h4>
<p>By default, <code>useEffect</code> will run after every render. However, most of the time, it should only re-run when needed rather than after every render. This can be controlled with the <em>dependency array</em>.</p>
<ul>
<li>ex. a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes.</li>
</ul>
<p><em>The question is not "when does this effect run", the question is "with which state does this effect synchronize with:"</em></p>
<ul>
<li><code>useEffect(fn)</code> - all state</li>
<li><code>useEffect(fn, [])</code> - no state</li>
<li><code>useEffect(fn, [these, states])</code></li>
</ul>
<p>If one of the variables in the dependency array changes, <code>useEffect</code> runs again. If the array is empty the hook doesn't run when updating the component at all, because it doesn't have to watch any variables.</p>
<p>You only need to include a variable in the dependency array if that variable changes due to a re-render.</p>
<ul>
<li>ex. if we define a variable that is defined outside the component, then it wouldn't change between renders. For this reason, it doesn't have to be a part of the dependency array.</li>
<li>Props, state, and other values declared inside the component are <em>reactive</em> because they’re calculated during rendering and participate in the React data flow. Therefore, they must be included in the dependency array.
<ul>
<li>by extension, any variable that is declared that uses any reactive variable is also reactive</li>
</ul>
</li>
<li><code>ref.current</code> is mutable and since changing it doesn’t trigger a re-render, it’s not a reactive value</li>
</ul>
<p>If you have no dependency array and are getting infinite loops, see if there are functions being defined each time in the component. It might be a simple fix to memoize them with <code>useCallback</code></p>
<ul>
<li>simply adding an empty dependency array is a bandaid solution and is not really addressing the root of the problem.</li>
</ul>
<p>The dependency array is used to specify which values from the component's scope should be captured by the closure. </p>
<ul>
<li>If a variable used in the <code>useEffect</code> is not listed in the dependency array and changes between renders, the effect will still capture the original value.
<ul>
<li>spec: verify this</li>
</ul>
</li>
</ul>
<h2 id="shortcoming-of-useeffect">Shortcoming of useEffect<a aria-hidden="true" class="anchor-heading icon-link" href="#shortcoming-of-useeffect"></a></h2>
<p>Compared to class component lifecycle methods, the shortcoming of <code>useEffect</code> is that while we can set new state, we are unable to access current state (because of stale closure)</p>
<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
        <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>In this example, <code>count</code> is always pointing to the previous reference.</p>
<ul>
<li>we can work around this shortcoming with <a href="/notes/xLeJix4672o4VYu5PYkNp">refs</a>. Essentially, because refs exist between renders, that value is never lost between mounts. We simply take the value from the ref, and update the state with that value:</li>
</ul>
<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
        countRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> countRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token function">setCount</span><span class="token punctuation">(</span>countRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p><a href="/notes/TNGo4AE63BetApHCGbQIE">this</a> is mutable state, and the problem with mutable state is that it is always up to date. The good thing about hooks in react is that there is no <code>this</code> to retrieve values from. State always stays the same within a given render of a component.</p>
<h3 id="useeffect-that-depends-on-a-function"><code>useEffect</code> that depends on a function<a aria-hidden="true" class="anchor-heading icon-link" href="#useeffect-that-depends-on-a-function"></a></h3>
<p>if your effect depends on a function, storing that function in a ref is a useful pattern. Like this:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> funcRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    funcRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> func
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// do some stuff and then call</span>
    funcRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token comment">/* ... */</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<hr>
<h3 id="using-multiple-useeffects">Using multiple <code>useEffect</code>s<a aria-hidden="true" class="anchor-heading icon-link" href="#using-multiple-useeffects"></a></h3>
<p>Each Effect should represent a separate synchronization process, and we should resist adding unrelated logic to our Effect only because this logic needs to run at the same time as an Effect we already wrote.</p>
<ul>
<li>ex. say you want to send an analytics event when the user visits the room. You already have an Effect that depends on roomId, so you might feel tempted to add the analytics call there:</li>
</ul>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatRoom</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">logVisit</span><span class="token punctuation">(</span>roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token method function property-access">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      connection<span class="token punctuation">.</span><span class="token method function property-access">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
<p>But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call logVisit(roomId) for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ChatRoom</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> roomId <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">logVisit</span><span class="token punctuation">(</span>roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> roomId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>roomId<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner.</p>
<h2 id="ue-resources">UE Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#ue-resources"></a></h2>
<ul>
<li><a href="https://react.dev/learn/you-might-not-need-an-effect">https://react.dev/learn/you-might-not-need-an-effect</a></li>
<li><a href="https://react.dev/learn/escape-hatches">https://react.dev/learn/escape-hatches</a></li>
</ul>