
Contract testing is a methodology for ensuring that two separate systems (such as two microservices) are compatible and are able to communicate with one other
- interactions exchanged between each service are captured, storing them in a contract, which can then be used to verify that both parties adhere to it.
- contract testing requires both parties to come to a consensus on the allowed set of interactions, and allowing for evolution over time.

The difference between contract testing and other methods that aim to achieve the same thing is that each system is able to be tested independently from the other and that the contract is generated by the code itself, meaning the contract is always kept up to date with reality.

How contract testing works:
![](/assets/images/2021-12-15-13-18-27.png)

The whole point of contract testing is to enable independent releases of components and [[continuous delivery|deploy.CD]].
- Coupling this way prevents this and scales poorly as you add more teams and components.

Contract testing is more relevant with a [[microservice|general.arch.microservice]] architecture, given its distributed nature.

Contract tests exist to help with [[integration testing|testing.method.integration]].
- In a distributed system, integration testing is a process that helps us validate that the various moving parts that communicate remotely - things like microservices, web applications and mobile applications - all work together cohesively.

During contract testing:
- Consumer side bargains to keep the [[test double|testing.test-double]] aligned with the contract.
- Producer does everything to follow the contract.

## Value of contract testing
Contract tests generally have the opposite properties to E2E-integrated tests:
- They run fast, because they don't need to talk to multiple systems.
- They are are easier to maintain: you don't need to understand the entire ecosystem to write your tests.
- They are easy to debug and fix, because the problem is only ever in the component you're testing - so you generally get a line number or a specific API endpoint that is failing.
- They are repeatable:
- They scale: because each component can be independently tested, build pipelines don't increase linearly / exponentially in time
- They uncover bugs locally, on developer machines: contract tests can and should run on developer machines prior to pushing code.
- Contract testing keeps the API producers in sync with the consumers.

Mostly used for:
- Detecting irregularities in a consumer workflow
- Detecting any service configuration defects
- Keeping the connections safe even when the producer changes any service configuration

In contract testing for message queues, for the purpose of verifying a contract, the underlying message queue is mostly irrelevant. As long as you can ensure that the message producer is generating a correctly formatted message, and the consumer is able to consume it, you donâ€™t need an actual message queue.

## Contract testing types
### Consumer-driven:

- In consumer-driven contract testing, the consumer oversees contract creation. You might wonder why would a consumer take in charge of contract creation?
- To understand that, let us assume there is a producer with many open service ports. A consumer wants to interact with this producer to access service port A.
- Here consumer needs to let the producer know about their needs. Hence the consumer creates a contract based on their requirements. All the system producers can access this contract.
- In this scenario for a successful interaction between the two parties, we follow the following steps:
	1. Producers test the consumer's requiremnts and produce a test response.
	2. Then the producer compares its response with the consumer's response.
	3. In case of a match between the responses, the two parties start to interact.

### Producer-driven:
- As compared to the consumer driven-contract testing a producer-driven contract testing is rarely used.
- In this testing, a producer takes charge of creating a contract between them and the consumer. Then the producer runs several build tests to meet the contract.
- If the producer passes all the test cases, then the results get stored in a common repository.
- The consumer then runs the build and test cases. Both parties interact only after passing all the test cases.

## Contract Testing Tools
- Pact

# E Resources
- https://dius.com.au/2017/08/22/contract-testing-serverless-and-asynchronous-applications/
