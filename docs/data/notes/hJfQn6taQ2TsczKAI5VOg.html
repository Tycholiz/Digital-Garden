<h1 id="json">Json<a aria-hidden="true" class="anchor-heading icon-link" href="#json"></a></h1>
<p>JSON is primarily intended to store whole documents that do not need to be manipulated inside the RDBMS</p>
<ul>
<li>Updating a row in Postgres always writes a new version of the whole row. That's the basic principle of Postgres' MVCC model. From a performance perspective, it hardly matters whether you change a single piece of data inside a JSON object or all of it: a new version of the row has to be written.</li>
<li>Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</li>
</ul>
<h2 id="working-with-json">Working with JSON<a aria-hidden="true" class="anchor-heading icon-link" href="#working-with-json"></a></h2>
<h3 id="functions">Functions<a aria-hidden="true" class="anchor-heading icon-link" href="#functions"></a></h3>
<p>imagine we pass a serialized json object as an argument to a postgres function like so:</p>
<pre><code>{
	username,
	avatar_url,
	email,
	first_name
}
</code></pre>
<p>We can then unpack that arg into a <em>declared</em> postgres variable:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">declare</span>
	v_email <span class="token operator">=</span> profile_object <span class="token operator">-</span><span class="token operator">>></span> <span class="token string">'email'</span><span class="token punctuation">;</span>
<span class="token comment">-- imagine this as `email = profile_object.email`</span>
<span class="token comment">-- `v_email :=` syntax is identical</span>
</code></pre>
<h4 id="--vs--">-> vs ->><a aria-hidden="true" class="anchor-heading icon-link" href="#--vs--"></a></h4>
<p><code>-></code>
Returns the field as <code>JSON</code></p>
<ul>
<li>because of this, we must use this for chaining to access deeply nested fields:</li>
</ul>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> info <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'items'</span> <span class="token operator">-</span><span class="token operator">>></span> <span class="token string">'product'</span> <span class="token keyword">as</span> product
</code></pre>
<p><code>->></code>
Returns the field as <code>text</code></p>
<h4 id="contains-">Contains (<code>@></code>)<a aria-hidden="true" class="anchor-heading icon-link" href="#contains-"></a></h4>
<p>We can check the JSON to see if it contains certain key-value pairs:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">select</span> media_items
<span class="token keyword">from</span> nuggets
<span class="token keyword">where</span> media_items @<span class="token operator">></span> <span class="token string">'{ "type": "text" }'</span>
</code></pre>
<h4 id="json-vs-jsonb">JSON vs JSONB<a aria-hidden="true" class="anchor-heading icon-link" href="#json-vs-jsonb"></a></h4>
<p>In general, most applications should prefer to store JSON data as jsonb, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</p>
<h5 id="json-1">JSON<a aria-hidden="true" class="anchor-heading icon-link" href="#json-1"></a></h5>
<ul>
<li>JSON - stores an exact copy of the input text, which processing functions must reparse on each execution
<ul>
<li>Because the json type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects</li>
</ul>
</li>
<li>JSON values can be manipulated, but must be cast to <code>text</code> first.</li>
</ul>
<h5 id="jsonb">JSONB<a aria-hidden="true" class="anchor-heading icon-link" href="#jsonb"></a></h5>
<ul>
<li>JSONB - stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed
<ul>
<li>also supports indexing on GIN and GIST index types.</li>
<li>does not preserve the order of object keys</li>
</ul>
</li>
<li>gives us capability to query into our JSON document for quick lookups</li>
</ul>
<hr>
<h1 id="e-resources">E Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#e-resources"></a></h1>
<p><a href="https://www.postgresqltutorial.com/postgresql-json/">https://www.postgresqltutorial.com/postgresql-json/</a></p>
<h1 id="ue-resources">UE Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#ue-resources"></a></h1>
<p><a href="https://github.com/postgrespro/jsquery">PG plugin to query jsonb data</a></p>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/notes/9laWSWa5iuZJMJaN5mXC3">Cook</a></li>
</ol>