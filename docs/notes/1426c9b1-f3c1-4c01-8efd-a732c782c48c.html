<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
  
  <title>Rxjs - Dendron</title>
  

  <link
    rel="shortcut icon"
    href="https://tycholiz.github.io/code-notes/favicon.ico"
    type="image/x-icon"
  />
  <link
    rel="stylesheet"
    href="https://tycholiz.github.io/code-notes/assets/css/just-the-docs-default.css"
  />
  <script
    type="text/javascript"
    src="https://tycholiz.github.io/code-notes/assets/js/just-the-docs.js"
  ></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X"
    crossorigin="anonymous"
  />
  <script
    type="text/javascript"
    src="https://tycholiz.github.io/code-notes/assets/js/vendor/lunr.min.js"
  ></script>
  
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   
  
<meta name="description" content="Personal knowledge space">
<meta name="author" content="">

<link rel="canonical" href="https://foo/notes/1426c9b1-f3c1-4c01-8efd-a732c782c48c.html">

<meta property="og:type" content="article">
<meta property="og:url" content="https://foo/notes/1426c9b1-f3c1-4c01-8efd-a732c782c48c.html">
<meta property="og:description" content="Personal knowledge space">
<meta property="og:image" content="https://fooundefined">

<meta name="twitter:card" content="summary">

<meta name="twitter:url" content="https://foo/notes/1426c9b1-f3c1-4c01-8efd-a732c782c48c.html">
<meta name="twitter:description" content="Personal knowledge space">
<meta name="twitter:image" content="https://fooundefined">


  <meta property="og:title" content="Rxjs - Dendron" />
  <meta name="twitter:title" content="Rxjs - Dendron" />
  
</head>


<body>
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
      <symbol id="svg-link" viewBox="0 0 24 24">
        <title>Link</title>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
          <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
        </svg>
      </symbol>
      <symbol id="svg-search" viewBox="0 0 24 24">
        <title>Search</title>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
          <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </symbol>
      <symbol id="svg-menu" viewBox="0 0 24 24">
        <title>Menu</title>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
          <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </symbol>
      <symbol id="svg-arrow-right" viewBox="0 0 24 24">
        <title>Expand</title>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </symbol>
      <symbol id="svg-doc" viewBox="0 0 24 24">
        <title>Document</title>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
          <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
        </svg>
      </symbol>
    </svg>

    <div class="side-bar">
      <div class="site-header">
        <a href="https://tycholiz.github.io/code-notes" class="site-title lh-tight">
  Dendron

 </a>
        <a href="#" id="menu-button" class="site-button">
          <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg>
        </a>
      </div>

      <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav">
      </nav>
      <footer class="site-footer">
        🌱 with 💕 using <a href="https://www.dendron.so/"> Dendron 🌲 </a>
      </footer>
    </div>
    <div class="main" id="top">
        <div id="main-header" class="main-header">
          
            <div class="search">
              <div class="search-input-wrap">
                <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dendron" aria-label="Search Dendron" autocomplete="off">
                <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
              </div>
              <div id="search-results" class="search-results"></div>
            </div>
          
          
    </div>
    <div id="main-content-wrap" class="main-content-wrap">
      
        
          <nav aria-label="Breadcrumb" class="breadcrumb-nav">
            <ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="https://tycholiz.github.io/code-notes">Root</a></li><li class="breadcrumb-nav-list-item"><a href="https://tycholiz.github.io/code-notes/notes/a02e32ca-2839-46bc-a452-684f01a4e671.html">Redux</a></li><li class="breadcrumb-nav-list-item"><a href="https://tycholiz.github.io/code-notes/notes/3a780b23-cc61-4f9c-a93a-1b4b90bdca74.html">Mw</a></li><li class="breadcrumb-nav-list-item">Rxjs</li></ol>
          </nav>
        
      
      <div id="main-content" class="main-content" role="main">

        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

        

        <script>
          $(function () {
            $('[data-toggle="popover"]').popover({html: true})
          })
        </script>

        

<div id="main" role="main">

  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Rxjs">
    
    <meta itemprop="datePublished" content="2021-03-07T22:35:06+00:00">
    <meta itemprop="dateModified" content="2021-03-07T22:38:53+00:00">

    <div class="page__inner-wrap">

      

      <section class="page__content" itemprop="text">

        

        <h1 id="rxjs"><a aria-hidden="true" class="anchor-heading" href="#rxjs"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Rxjs</h1>
<p>observables are conceptually similar to a fancy event emitter.</p>
<h1 id="observable"><a aria-hidden="true" class="anchor-heading" href="#observable"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Observable</h1>
<ul>
<li>
<p><strong><em>Observable</em></strong> - A data structure representing the idea of an invokable collection of future values or events</p>
<ul>
<li>in other words, they are a representation of any set of values over any amount of time</li>
</ul>
</li>
<li>
<p>Observables are lazy Push collections of multiple values</p>
</li>
<li>
<p>variables that reference a stream are denoted with <code>$</code> (ex. <code>action$</code>)</p>
<ul>
<li>ex. <em>observable</em></li>
</ul>
</li>
<li>
<p>An observable is a function that returns a stream</p>
</li>
<li>
<p>An observable is a function that takes an observer and returns a cancellation function</p>
<ul>
<li>an observer is an object with <code>next</code>, <code>error</code> and <code>complete</code> methods</li>
</ul>
</li>
<li>
<p>Observables are inert (they just sit there until they are <em>subscribed</em> to), while observers stay active and listen for events from the producers</p>
</li>
<li>
<p>The problem is this: we can consider an array where we already know all the values as eager, and an array that receives values (ie. increases length) at a set interval (1s) as lazy. Normally, we perform data processing in an eager way, since the data is processed immediately as it's received, which is instant. What if we are in a position where the array grows over time? It would be beneficial if we could call a method on an array value as it enters the array. In this sense, we need to subscribe to the array to execute a method when the array grows.</p>
</li>
<li>
<p>There are 2 sides to an observable: producer and consumer</p>
<ul>
<li><strong>Producer</strong> - adds to the array
<ul>
<li>ex. button clicks add that click event to the array</li>
</ul>
</li>
<li><strong>Consumer</strong> - calls the function on the new array item
<ul>
<li>ex. calls <code>console.log</code> in response to the new click event</li>
</ul>
</li>
</ul>
</li>
<li>
<p>An <code>Observer</code> subscribes (ie. is consumer) to an <code>Observable</code></p>
<ul>
<li>an observer is a collection of callbacks</li>
</ul>
</li>
<li>
<p>Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:
<img src="/assets/images/2021-03-07-22-35-55.png"></p>
<pre><code>- They *push* with `.next()`
</code></pre>
</li>
</ul>
<h2 id="characteristics"><a aria-hidden="true" class="anchor-heading" href="#characteristics"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Characteristics</h2>
<ul>
<li>
<p>They are time-independent (ie. lazy)</p>
</li>
<li>
<p>They are mostly used in asynchronous data streams, like web sockets or multiple concurrent api calls</p>
</li>
<li>
<p>Just as promises abstract time away from our concern for a single asynchronous operation, observables abstract time away from a set of data (eg. array)</p>
<ul>
<li>ex. Observable can be set up to listen for mouseclicks, by pushing onto an array each time the mouse is clicked. The fact that the <em>subscribed</em> function exists means that it will fire whenever the array increases in size.</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>If you combine the functionality of an Observer and an Observable, you get a Subject</p>
</li>
<li>
<p>each operator on an Observable returns a new Observable, meaning they are chainable (this is known as a <em>stream</em>)</p>
</li>
<li>
<p>A map(..) on an array runs its mapping function once for each value currently in the array, putting all the mapped values in the outcome array. A map(..) on an Observable runs its mapping function once for each value, whenever it comes in, and pushes all the mapped values to the output Observable.</p>
</li>
</ul>
<p><strong>epic</strong> - a collection of observables</p>
<pre><code>export default function fetchTeams(action$) {
    // epic
    return action$.pipe(
        //operator
        ofType('FLASHCARDS_TEAMS_GET'), 
        //operator
        switchMap(() => 
            queryGraphQL('flashcards__teams'),
        ),
        //operator
        map(resp => { operator
            const flattenedData = flattenGraphqlNode(resp).data.teams;
            return getTeamsSuccess(flattenedData);
        }),
        catchError(err => {
            getError(err);
        }),
    );
}
</code></pre>
<h2 id="using-observables"><a aria-hidden="true" class="anchor-heading" href="#using-observables"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Using observables</h2>
<ul>
<li>An <code>observable</code> is a function that takes in an <code>observer</code> (an object with <code>next</code>, <code>error</code>, and <code>complete</code>) and returns cancellation logic (i.e. unsubscribe).</li>
<li><code>.next()</code> is called when the observable produces values</li>
<li>When an observer subscribes to an observable, the observer will keep receiving values until one of 2 things happens:
<ul>
<li>there are no more values to be sent (in which case <code>.complete()</code> is called)</li>
<li>the observer calls <code>.unsubscribe()</code> on the observer</li>
</ul>
</li>
<li>fromEvent will turn an event into an observable
<ul>
<li><code>fromEvent(&#x3C;event to be listened to>, &#x3C;eventName>)</code></li>
</ul>
</li>
</ul>
<pre><code>const input$ = Rx.Observable.fromEvent(node, 'input')
  .map(event => event.target.value)
  .filter(value => value.length >= 2)
  .subscribe(value => {
    // use the `value`
  });
</code></pre>
<p>Here are the steps of this sequence:</p>
<ol>
<li>Let’s assume the user types the letter “a” into our input (node is a variable that has query selected the html input element)</li>
<li>The Observable then reacts to this event, passing the value to the next observer</li>
<li>The value “a” is passed to <code>.map()</code>, which is subscribing to our initial observable</li>
<li><code>.map()</code> returns a new Observable of event.target.value and calls <code>.next()</code> on it’s observer</li>
<li>The <code>.next()</code> call will invoke <code>.filter()</code>, which is subscribing to <code>.map()</code>, with the resulting value of the .map() call</li>
<li>.filter() will then return another Observable with the filtered results, calling <code>.next()</code> with the value if the length is 2 or above</li>
<li>We get the final value through our <code>.subscribe()</code> block</li>
</ol>
<ul>
<li>Each time a new Observable is returned, a new observer is hooked up to the previous Observable (allowing us to pass values along a stream of observers, which do something we've asked, then call <code>.next()</code>, then pass the result to the next observer.
<ul>
<li>Basically, an operator returns a new Observable each time, allowing the stream to continue</li>
</ul>
</li>
</ul>
<h2 id="subscription"><a aria-hidden="true" class="anchor-heading" href="#subscription"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Subscription</h2>
<ul>
<li><strong><em>subscription</em></strong> - an object that represents the execution of an <em>observable</em></li>
<li><code>.create</code> accepts a subscribe function
<ul>
<li><code>subscribe</code> accepts an <em>observer argument</em></li>
</ul>
</li>
</ul>
<pre><code>// This first part is the observable, which emits things
const myObservable = Observable.create(function subscribe(observer) {
    observer.next('hey!') //this is emitting a value
})

// To grab the value, we define an observer 
// (x is the observer)
const observer = myObservable.subscribe((x) {
    console.log(x) // hey!
})
</code></pre>
<h2 id="mapping--flattening-operators"><a aria-hidden="true" class="anchor-heading" href="#mapping--flattening-operators"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>"Mapping + Flattening" Operators</h2>
<ul>
<li><strong><em>flatten</em></strong> - subscribing inside a subscribe</li>
<li>All work mostly in same manner
<ul>
<li>They map some value to an observable (you are the one in charge of returning an observable value from them, they just map it)</li>
<li>They flatten the observable you return ( they just subscribe to it)</li>
<li>They decide about what to do before / after they flatten (“Flattening Strategy”)</li>
</ul>
</li>
</ul>
<h3 id="mergemap---the-slacker-operator"><a aria-hidden="true" class="anchor-heading" href="#mergemap---the-slacker-operator"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>mergeMap - the slacker operator</h3>
<ul>
<li>simply keep subscribing to every new observable that we return from the map</li>
<li>Other than mapping + flattening the observable, it does nothing else.</li>
<li>ex. Imagine Netflix shows up-to-date ratings for each movie, retrieved from IMDB's API. We can <code>mergeMap</code> the movie into an http request to IMDB to get this data and enhance our UI.</li>
</ul>
<h3 id="switchmap---the-latest-and-greatest-operator"><a aria-hidden="true" class="anchor-heading" href="#switchmap---the-latest-and-greatest-operator"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>switchMap - the "latest and greatest" operator</h3>
<ul>
<li>unsubscribe from the last mapped observable</li>
<li>ex. Imagine we are typing in Google and the autocomplete box shows up. Of course, these suggestions change with each key press. If we use <code>switchMap</code>, each previous request will be cancelled if a new one happens. If we'd used <code>mergeMap</code>, a request for each keystroke would be made</li>
</ul>
<h3 id="concatmap---the-wait-in-line-operator"><a aria-hidden="true" class="anchor-heading" href="#concatmap---the-wait-in-line-operator"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>concatMap - the "wait in line" operator</h3>
<ul>
<li>queue up the observables one after the other, and play their events in that order (i.e. subscribe to the next Observable in the queue only when the previous one is completed).</li>
<li>Similar to <code>mergeMap</code>, except order matters</li>
<li>ex. top 10 list</li>
</ul>
<h3 id="exhaustmap---the-do-not-disturb-operator"><a aria-hidden="true" class="anchor-heading" href="#exhaustmap---the-do-not-disturb-operator"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>exhaustMap - the "do not disturb" operator</h3>
<ul>
<li>ex. login button - since we don't want multiple clicks to be registered, we want want to disable mapping while the first http request is on the go, ensuring that we never call the server while the current request is running.</li>
</ul>
<h1 id="redux-observable-library"><a aria-hidden="true" class="anchor-heading" href="#redux-observable-library"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Redux-Observable (library)</h1>
<ul>
<li><strong><em>def</em></strong> - a redux middlware allowing us to <code>map</code> and <code>filter</code> actions with RxJS operators.
<ul>
<li>While javascript <code>map</code> and <code>reduce</code> allows us to transform arrays, these versions allow us to transform <em>streams of actions</em></li>
</ul>
</li>
</ul>
<h2 id="epic"><a aria-hidden="true" class="anchor-heading" href="#epic"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Epic</h2>
<ul>
<li><strong><em>def</em></strong> - a function that takes in a stream of actions, and returns a modified stream of actions.
<ul>
<li>receive <code>variable$</code> as input</li>
</ul>
</li>
<li>epics can be thought of as a description of what additional actions redux-observable should dispatch</li>
<li>epics are analogous to sagas from redux-saga</li>
</ul>
<p>example:</p>
<pre><code>const pingEpic = action$ => action$.pipe(
  ofType('PING'), //equivalent to filter(action => action.type === 'PING')
  mapTo({ type: 'PONG' })
);

// later...
dispatch({ type: 'PING' });
</code></pre>
<ul>
<li>pingEpic will listen for actions of type PING and map them to a new action, PONG. This example is functionally equivalent to doing this:</li>
</ul>
<pre><code>dispatch({ type: 'PING' });
dispatch({ type: 'PONG' });
</code></pre>
<ul>
<li>Epics run alongside the normal Redux dispatch channel, after the reducers have already received them. When you map an action to another one, you are not preventing the original action from reaching the reducers; that action has already been through them</li>
</ul>
<h2 id="operators"><a aria-hidden="true" class="anchor-heading" href="#operators"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Operators</h2>
<ul>
<li><code>ofType</code> - filter by a specific type of action</li>
</ul>
<h1 id="stream"><a aria-hidden="true" class="anchor-heading" href="#stream"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Stream</h1>
<ul>
<li><strong><em>def</em></strong> - a sequence of data elements made available over time</li>
<li>Can be thought of as items on a conveyor belt being processed one at a time, rather than in large batches</li>
<li>Can also be seen as a sequence of ongoing events ordered in time
<ul>
<li>ex. number of button clicks in 1 second
<ul>
<li>All the clicks will be grouped together as a stream</li>
</ul>
</li>
</ul>
</li>
<li>The stream is the subject which is being observed</li>
</ul>
<hr>
<h3 id="promise-vs-observable"><a aria-hidden="true" class="anchor-heading" href="#promise-vs-observable"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise vs Observable</h3>
<ul>
<li>Promises handle a single event (ie. the failure or success of an asyn operation).</li>
<li>An observable is a function that returns a stream, and we can pass in zero or more events to it. The callback provided to the observable will be called for each event.
<ul>
<li>Observables are preferred over promises because they don't care how many events you have, while promises require 1, and only 1.</li>
</ul>
</li>
<li>Observable libraries provide methods to help interact with the emitted (returned?) value(s). For instance, we can use <code>map</code> to transform each value's output </li>
<li>a Promise is eager, whereas an Observable is lazy</li>
<li>If you wanted to subscribe to the reactive way of programming, then you could just "observable all the things"</li>
</ul>
<p>Additionally...</p>
<ul>
<li>Observables are cancellable.</li>
</ul>
<h1 id="questions"><a aria-hidden="true" class="anchor-heading" href="#questions"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Questions</h1>
<ul>
<li>what is meant by inner/outer observable
<ul>
<li><a href="https://academind.com/learn/javascript/callbacks-vs-promises-vs-rxjs-vs-async-awaits/">source</a> </li>
</ul>
</li>
</ul>
<h1 id="resources"><a aria-hidden="true" class="anchor-heading" href="#resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Resources</h1>
<ul>
<li><a href="http://reactivex.io/documentation/operators.html">Operators</a></li>
<li><a href="https://rangle.io/blog/thinking-in-nested-streams-with-rxjs/">thinking in nested streams</a></li>
</ul><span id="navId" data="1426c9b1-f3c1-4c01-8efd-a732c782c48c"></span>

                
      </section>

      
    </div>

    
  </article>

  
  
</div>


        
          <hr>
          <footer>
            
            

            
                
              </div>
          </footer>
        
    </div>
</div>


  

  <div class="search-overlay"></div>

</div>
</body>
</html>
