<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Rebase</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Publishable tech notes"/><meta property="og:title" content="Rebase"/><meta property="og:description" content="Publishable tech notes"/><meta property="og:url" content="https://tycholiz.github.io/Digital-Garden/notes/QyhBiiMo8hlLxdGY9WX7K/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="3/26/2021"/><meta property="article:modified_time" content="7/24/2021"/><link rel="canonical" href="https://tycholiz.github.io/Digital-Garden/notes/QyhBiiMo8hlLxdGY9WX7K/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/Digital-Garden/_next/static/css/804c5fc85a5d7e04.css" as="style"/><link rel="stylesheet" href="/Digital-Garden/_next/static/css/804c5fc85a5d7e04.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Digital-Garden/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/Digital-Garden/_next/static/chunks/webpack-d53c65e15128d807.js" defer=""></script><script src="/Digital-Garden/_next/static/chunks/framework-dc33c0b5493501f0.js" defer=""></script><script src="/Digital-Garden/_next/static/chunks/main-9409ea3202b3ee44.js" defer=""></script><script src="/Digital-Garden/_next/static/chunks/pages/_app-585c2573c1834e35.js" defer=""></script><script src="/Digital-Garden/_next/static/chunks/155-0a8d44b6408c244d.js" defer=""></script><script src="/Digital-Garden/_next/static/chunks/pages/notes/%5Bid%5D-30a63e62504f2dc5.js" defer=""></script><script src="/Digital-Garden/_next/static/s-Pdpb0Y8fVIEUakhzEMN/_buildManifest.js" defer=""></script><script src="/Digital-Garden/_next/static/s-Pdpb0Y8fVIEUakhzEMN/_ssgManifest.js" defer=""></script><script src="/Digital-Garden/_next/static/s-Pdpb0Y8fVIEUakhzEMN/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div class="ant-col ant-col-xs-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"></div><div class="ant-col ant-col-xs-12"></div><div style="margin-left:4px;display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout site-layout" style="margin-top:64px"><section class="ant-layout site-layout" style="flex-direction:row"><section class="ant-layout site-layout-sidebar" style="flex:0 0 auto;width:calc((100% - 992px) / 2 + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></section><section class="ant-layout side-layout-main" style="max-width:1200px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="rebase"><a aria-hidden="true" class="anchor-heading" href="#rebase"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Rebase</h1>
<h1 id="overview"><a aria-hidden="true" class="anchor-heading" href="#overview"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Overview</h1>
<p>From a feature branch (FB), if we rebase master, conceptually we are rewinding back to the point where the FB split from master and updating that point with master and then “replaying” the FB commits on top of that</p>
<ul>
<li>Therefore, rebase is an alternative way to get commits from a feature branch onto a master branch
<ul>
<li>with <code>git merge</code>, we take all of the commits on the feature branch and try and jam them together with the commits of the master branch, in order to make a new commit (the merge commit).</li>
<li>with <code>git rebase</code>, we take all of the commits from the current branch and move them on top of another. This involves rebasing first, then doing a regular merge (which will be fast-forward, since the base commit will now be a direct ancestor)
<ul>
<li>When we run <code>git rebase master</code> from our feature branch, we say "hey master, I want to take all the work I've done so far and make it look like it was built directly on top of all of the work that <em>you</em> have"</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If you're <code>rebase</code>ing, you will always have to <code>--force</code> when you push, because rebase rewrites history— That's simply how it works. Rewritten history isn't going to fast-forward on top of that same history by definition.</p>
<ul>
<li>only the commits that are being replayed are rewritten (and thus, new SHAs). If we are on FB and rebasing on top of master, the commits from master will remain unchanged (ie. history isn't being written here). However, the commits that only existed on FB will be rewritten, and thus will have new SHAs.</li>
<li>While collaborating with others using the "rebase workflow", you should always <code>git pull --rebase</code> to avoid the circumstance where a merge commit is made. If one person rebases, and then pulls that code with merge commits, it will be a difficult rebase (spec:) due to the rewritten history.</li>
</ul>
<p>As the name suggests, rebase exists to change the base of a branch (ie. the origin commit). We do this by replaying a series of commits on top of a new base.</p>
<ul>
<li>
<p>This is mostly needed when a series of local commits is deemed to start from an obsolete base (put another way, our local master is very out of sync with origin/master)</p>
</li>
<li>
<p>behind the scenes, git is duplicating the commits of the feature branch, putting them on top of the master branch, and then blowing away those original feature branch's commits (hence why they are greyed out in the following image).</p>
<ul>
<li>therefore, in a sense it is rewriting history, as evidenced by the fact that the duplicated commits have a different SHA than the originals</li>
</ul>
</li>
<li>
<p>Because rebase rewrites history, it's important that we pull all remote changes to our local master branch before rebasing, so that we are reanchoring our feature branch's commits to the current version of the code.</p>
</li>
<li>
<p>ex. we are on branch <code>about</code>, which has diverged from <code>master</code>. We want to incorporate changes from master into <code>about</code>. From <code>about</code>, we run <code>git rebase master</code>:</p>
</li>
</ul>
<h2 id="process"><a aria-hidden="true" class="anchor-heading" href="#process"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Process</h2>
<p>Git always squashes a newer commit into an older commit or “upward” as viewed on the interactive rebase todo list, that is into a commit on a previous line.</p>
<ul>
<li>This means if commit1 is a <code>WIP</code> commit, and commit2 is the one we want to keep (along with changes from commit1), then we must actually <code>squash</code> commit2 into commit1. Doing so will allow us modify the commit message (now a combination of the messages from commit1 and commit2) before rewriting the history.</li>
</ul>
<h3 id="behind-the-scenes"><a aria-hidden="true" class="anchor-heading" href="#behind-the-scenes"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Behind the Scenes</h3>
<ol>
<li>Git will checkout the upstream branch and copy all the changes you've done since you last merged, placing them on the tip of the upstream branch.
<ul>
<li>ex. in the above image, to an outside observer it would seem that you had checked out the upstream branch from <strong><em>a</em></strong>b and then done your changes.</li>
<li>note: here upstream most likely is origin/master or simply master, but it could be any branch we are "merging" into.</li>
</ul>
</li>
<li>Git produces a series of patch files of your work and starts applying them to the upstream branch.
<ul>
<li>consider that these commits are actual copies with different commit SHAs</li>
</ul>
</li>
</ol>
<h3 id="process-1"><a aria-hidden="true" class="anchor-heading" href="#process-1"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Process</h3>
<ol>
<li>when finished with feature branch, pull all remote changes onto master
<ul>
<li>if local master === origin/master, step 2 can be skipped, since it would have no effect anyway</li>
</ul>
</li>
<li>from feature branch, run <code>git rebase master</code>, which will cause our feature branch commits to be anchored against the updated master branch
<ul>
<li>consider that when we checkout a new branch, we have a common base with the branch which we checked out from. Rebasing master here ensures that the remote changes that happened and got merged into master (remotely) are included as part of that anchor.</li>
</ul>
</li>
<li>from master branch, run <code>git rebase feature-branch</code>, copying and placing the commits of the feature branch onto the main branch.</li>
</ol>
<h4 id="conflicts"><a aria-hidden="true" class="anchor-heading" href="#conflicts"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Conflicts</h4>
<ul>
<li>say we are rebasing 8 commits onto the new branch — each one could cause a conflict, and we can resolve the conflicts introduced by each commit one by one.
<ul>
<li>fix the file, run <code>git add</code>, then run <code>git rebase --continue</code> (which moves us on to the next patch, until all are completed)</li>
</ul>
</li>
</ul>
<h3 id="when-to-use-rebase"><a aria-hidden="true" class="anchor-heading" href="#when-to-use-rebase"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>When to use rebase</h3>
<ol>
<li>Any time we are working on a long term branch that needs to stay somewhat up to date with master. It is better to keep it as up to date as possible, rather than staying diverged for a long time.
<ul>
<li>ex. Imagine working on an experimental branch and getting blocked at some point. This is a scenario that would cause your branch to diverge from master more and more over time. When it does come time to pick up work again, it would be a good time to rebase to the master branch. The result is that it would look just like you started from there.</li>
</ul>
</li>
<li>Consider that in a perfect world, my coworker and I would have a linear commit history (even though we are developing asynchronously, it makes more sense looking back if we have a straight line of commits). In this ideal world, I would be developing my work off the base of my coworker's work, and vice versa.</li>
<li>Imagine we have a <em>quick-fix</em> branch that we don't want muddying up the history. If master has not been touched since we branched, the ff merge is automatic. However, if master has indeed changed, then we need a way to tweak <em>quick-fix</em> so it becomes a direct descendent of <em>master</em> again.
<ul>
<li>In this scenario, we want our local master to have the same tip as origin/master. This would allow us to do a ff merge, thus avoiding muddying up history.</li>
</ul>
</li>
</ol>
<h3 id="drawbacks-to-rebase"><a aria-hidden="true" class="anchor-heading" href="#drawbacks-to-rebase"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Drawbacks to rebase</h3>
<ul>
<li>doesn't play too well with open source projects, since it becomes hard to trace changes introduced to a codebase.</li>
<li>doesn't work well when working on a shared branch, since commits are rewritten.</li>
<li>only rebase when working on a local branch prior to pushing, or on remote repos where you are the only contributor (ex. for backup purposes).
<ul>
<li>In the second scenario, we'll need to force push (since we replaced its commit history with a fresh one).</li>
<li>Issues arise when other people pull in objects that were orphaned by the rebase process.</li>
</ul>
</li>
</ul>
<h4 id="shared-branches"><a aria-hidden="true" class="anchor-heading" href="#shared-branches"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Shared branches</h4>
<p>Rebase is not a great candidate for shared branches. Because <code>git push --force</code> is a fact of life to the "rebase-way" of Git workflow, we would have to be careful to check if someone else has pushed to the remote branch first. This is why we should use <code>--force-with-lease</code>, so that we cannot overwrite commits that have been pushed already to that remote branch. If there have been, we will get errors, and we can <code>git pull --rebase</code> to incorporate those changes, before force pushing again.</p>
<h2 id="long-lived-feature-branches-llfb"><a aria-hidden="true" class="anchor-heading" href="#long-lived-feature-branches-llfb"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Long-lived Feature Branches (LLFB)</h2>
<p>as the LLFB gets periodically rebased off master its commits get rewritten, so we end up with different SHAs for "the same" content of the commit.</p>
<h1 id="e-resources"><a aria-hidden="true" class="anchor-heading" href="#e-resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>E Resources</h1>
<p><a href="https://m.youtube.com/watch?v=P5p71fguFNI">VS Code tip: Interactive rebase editor from the GitLens extension</a></p>
<hr>
<h2 id="children"><a aria-hidden="true" class="anchor-heading" href="#children"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Children</h2>
<ol>
<li><a href="/Digital-Garden/notes/R6NsoPat1BmEDwycbn5q6">Cook</a></li>
</ol></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#overview" title="Overview">Overview</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#process" title="Process">Process</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#behind-the-scenes" title="Behind the Scenes">Behind the Scenes</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#process-1" title="Process">Process</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#conflicts" title="Conflicts">Conflicts</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#when-to-use-rebase" title="When to use rebase">When to use rebase</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#drawbacks-to-rebase" title="Drawbacks to rebase">Drawbacks to rebase</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#shared-branches" title="Shared branches">Shared branches</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#long-lived-feature-branches-llfb" title="Long Lived Feature Branches (LLFB)">Long Lived Feature Branches (LLFB)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#e-resources" title="E Resources">E Resources</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"QyhBiiMo8hlLxdGY9WX7K","title":"Rebase","desc":"","updated":1627107308238,"created":1616785039322,"stub":false,"custom":{"stub":false},"fname":"git.cli.rebase","type":"note","vault":{"fsPath":"../main/tech","name":"tech"},"contentHash":"1d226788f740a490179d101518925b23","links":[],"anchors":{"overview":{"type":"header","text":"Overview","value":"overview","line":9,"column":0,"depth":1},"process":{"type":"header","text":"Process","value":"process","line":29,"column":0,"depth":2},"behind-the-scenes":{"type":"header","text":"Behind the Scenes","value":"behind-the-scenes","line":34,"column":0,"depth":3},"process-1":{"type":"header","text":"Process","value":"process-1","line":41,"column":0,"depth":3},"conflicts":{"type":"header","text":"Conflicts","value":"conflicts","line":48,"column":0,"depth":4},"when-to-use-rebase":{"type":"header","text":"When to use rebase","value":"when-to-use-rebase","line":52,"column":0,"depth":3},"drawbacks-to-rebase":{"type":"header","text":"Drawbacks to rebase","value":"drawbacks-to-rebase","line":59,"column":0,"depth":3},"shared-branches":{"type":"header","text":"Shared branches","value":"shared-branches","line":66,"column":0,"depth":4},"long-lived-feature-branches-llfb":{"type":"header","text":"Long-lived Feature Branches (LLFB)","value":"long-lived-feature-branches-llfb","line":69,"column":0,"depth":2},"e-resources":{"type":"header","text":"E Resources","value":"e-resources","line":72,"column":0,"depth":1}},"children":["R6NsoPat1BmEDwycbn5q6"],"parent":"wgiwNFC5iqnWdSZT9yYET","data":{}},"body":"\u003ch1 id=\"rebase\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#rebase\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eRebase\u003c/h1\u003e\n\u003ch1 id=\"overview\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#overview\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eOverview\u003c/h1\u003e\n\u003cp\u003eFrom a feature branch (FB), if we rebase master, conceptually we are rewinding back to the point where the FB split from master and updating that point with master and then “replaying” the FB commits on top of that\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTherefore, rebase is an alternative way to get commits from a feature branch onto a master branch\n\u003cul\u003e\n\u003cli\u003ewith \u003ccode\u003egit merge\u003c/code\u003e, we take all of the commits on the feature branch and try and jam them together with the commits of the master branch, in order to make a new commit (the merge commit).\u003c/li\u003e\n\u003cli\u003ewith \u003ccode\u003egit rebase\u003c/code\u003e, we take all of the commits from the current branch and move them on top of another. This involves rebasing first, then doing a regular merge (which will be fast-forward, since the base commit will now be a direct ancestor)\n\u003cul\u003e\n\u003cli\u003eWhen we run \u003ccode\u003egit rebase master\u003c/code\u003e from our feature branch, we say \"hey master, I want to take all the work I've done so far and make it look like it was built directly on top of all of the work that \u003cem\u003eyou\u003c/em\u003e have\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you're \u003ccode\u003erebase\u003c/code\u003eing, you will always have to \u003ccode\u003e--force\u003c/code\u003e when you push, because rebase rewrites history— That's simply how it works. Rewritten history isn't going to fast-forward on top of that same history by definition.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eonly the commits that are being replayed are rewritten (and thus, new SHAs). If we are on FB and rebasing on top of master, the commits from master will remain unchanged (ie. history isn't being written here). However, the commits that only existed on FB will be rewritten, and thus will have new SHAs.\u003c/li\u003e\n\u003cli\u003eWhile collaborating with others using the \"rebase workflow\", you should always \u003ccode\u003egit pull --rebase\u003c/code\u003e to avoid the circumstance where a merge commit is made. If one person rebases, and then pulls that code with merge commits, it will be a difficult rebase (spec:) due to the rewritten history.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs the name suggests, rebase exists to change the base of a branch (ie. the origin commit). We do this by replaying a series of commits on top of a new base.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThis is mostly needed when a series of local commits is deemed to start from an obsolete base (put another way, our local master is very out of sync with origin/master)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebehind the scenes, git is duplicating the commits of the feature branch, putting them on top of the master branch, and then blowing away those original feature branch's commits (hence why they are greyed out in the following image).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etherefore, in a sense it is rewriting history, as evidenced by the fact that the duplicated commits have a different SHA than the originals\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBecause rebase rewrites history, it's important that we pull all remote changes to our local master branch before rebasing, so that we are reanchoring our feature branch's commits to the current version of the code.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eex. we are on branch \u003ccode\u003eabout\u003c/code\u003e, which has diverged from \u003ccode\u003emaster\u003c/code\u003e. We want to incorporate changes from master into \u003ccode\u003eabout\u003c/code\u003e. From \u003ccode\u003eabout\u003c/code\u003e, we run \u003ccode\u003egit rebase master\u003c/code\u003e:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"process\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#process\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eProcess\u003c/h2\u003e\n\u003cp\u003eGit always squashes a newer commit into an older commit or “upward” as viewed on the interactive rebase todo list, that is into a commit on a previous line.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThis means if commit1 is a \u003ccode\u003eWIP\u003c/code\u003e commit, and commit2 is the one we want to keep (along with changes from commit1), then we must actually \u003ccode\u003esquash\u003c/code\u003e commit2 into commit1. Doing so will allow us modify the commit message (now a combination of the messages from commit1 and commit2) before rewriting the history.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"behind-the-scenes\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#behind-the-scenes\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eBehind the Scenes\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eGit will checkout the upstream branch and copy all the changes you've done since you last merged, placing them on the tip of the upstream branch.\n\u003cul\u003e\n\u003cli\u003eex. in the above image, to an outside observer it would seem that you had checked out the upstream branch from \u003cstrong\u003e\u003cem\u003ea\u003c/em\u003e\u003c/strong\u003eb and then done your changes.\u003c/li\u003e\n\u003cli\u003enote: here upstream most likely is origin/master or simply master, but it could be any branch we are \"merging\" into.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eGit produces a series of patch files of your work and starts applying them to the upstream branch.\n\u003cul\u003e\n\u003cli\u003econsider that these commits are actual copies with different commit SHAs\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"process-1\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#process-1\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eProcess\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003ewhen finished with feature branch, pull all remote changes onto master\n\u003cul\u003e\n\u003cli\u003eif local master === origin/master, step 2 can be skipped, since it would have no effect anyway\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efrom feature branch, run \u003ccode\u003egit rebase master\u003c/code\u003e, which will cause our feature branch commits to be anchored against the updated master branch\n\u003cul\u003e\n\u003cli\u003econsider that when we checkout a new branch, we have a common base with the branch which we checked out from. Rebasing master here ensures that the remote changes that happened and got merged into master (remotely) are included as part of that anchor.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efrom master branch, run \u003ccode\u003egit rebase feature-branch\u003c/code\u003e, copying and placing the commits of the feature branch onto the main branch.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"conflicts\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#conflicts\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eConflicts\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003esay we are rebasing 8 commits onto the new branch — each one could cause a conflict, and we can resolve the conflicts introduced by each commit one by one.\n\u003cul\u003e\n\u003cli\u003efix the file, run \u003ccode\u003egit add\u003c/code\u003e, then run \u003ccode\u003egit rebase --continue\u003c/code\u003e (which moves us on to the next patch, until all are completed)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"when-to-use-rebase\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#when-to-use-rebase\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eWhen to use rebase\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eAny time we are working on a long term branch that needs to stay somewhat up to date with master. It is better to keep it as up to date as possible, rather than staying diverged for a long time.\n\u003cul\u003e\n\u003cli\u003eex. Imagine working on an experimental branch and getting blocked at some point. This is a scenario that would cause your branch to diverge from master more and more over time. When it does come time to pick up work again, it would be a good time to rebase to the master branch. The result is that it would look just like you started from there.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eConsider that in a perfect world, my coworker and I would have a linear commit history (even though we are developing asynchronously, it makes more sense looking back if we have a straight line of commits). In this ideal world, I would be developing my work off the base of my coworker's work, and vice versa.\u003c/li\u003e\n\u003cli\u003eImagine we have a \u003cem\u003equick-fix\u003c/em\u003e branch that we don't want muddying up the history. If master has not been touched since we branched, the ff merge is automatic. However, if master has indeed changed, then we need a way to tweak \u003cem\u003equick-fix\u003c/em\u003e so it becomes a direct descendent of \u003cem\u003emaster\u003c/em\u003e again.\n\u003cul\u003e\n\u003cli\u003eIn this scenario, we want our local master to have the same tip as origin/master. This would allow us to do a ff merge, thus avoiding muddying up history.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"drawbacks-to-rebase\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#drawbacks-to-rebase\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eDrawbacks to rebase\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003edoesn't play too well with open source projects, since it becomes hard to trace changes introduced to a codebase.\u003c/li\u003e\n\u003cli\u003edoesn't work well when working on a shared branch, since commits are rewritten.\u003c/li\u003e\n\u003cli\u003eonly rebase when working on a local branch prior to pushing, or on remote repos where you are the only contributor (ex. for backup purposes).\n\u003cul\u003e\n\u003cli\u003eIn the second scenario, we'll need to force push (since we replaced its commit history with a fresh one).\u003c/li\u003e\n\u003cli\u003eIssues arise when other people pull in objects that were orphaned by the rebase process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"shared-branches\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#shared-branches\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eShared branches\u003c/h4\u003e\n\u003cp\u003eRebase is not a great candidate for shared branches. Because \u003ccode\u003egit push --force\u003c/code\u003e is a fact of life to the \"rebase-way\" of Git workflow, we would have to be careful to check if someone else has pushed to the remote branch first. This is why we should use \u003ccode\u003e--force-with-lease\u003c/code\u003e, so that we cannot overwrite commits that have been pushed already to that remote branch. If there have been, we will get errors, and we can \u003ccode\u003egit pull --rebase\u003c/code\u003e to incorporate those changes, before force pushing again.\u003c/p\u003e\n\u003ch2 id=\"long-lived-feature-branches-llfb\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#long-lived-feature-branches-llfb\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eLong-lived Feature Branches (LLFB)\u003c/h2\u003e\n\u003cp\u003eas the LLFB gets periodically rebased off master its commits get rewritten, so we end up with different SHAs for \"the same\" content of the commit.\u003c/p\u003e\n\u003ch1 id=\"e-resources\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#e-resources\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eE Resources\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://m.youtube.com/watch?v=P5p71fguFNI\"\u003eVS Code tip: Interactive rebase editor from the GitLens extension\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"children\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#children\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eChildren\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/Digital-Garden/notes/R6NsoPat1BmEDwycbn5q6\"\u003eCook\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","noteIndex":{"id":"olZIVfSs2uLLr3BppFh4K","title":"Root","desc":"","updated":1618676699718,"created":1615482407722,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"../main/tech","name":"tech"},"contentHash":"777fb4dab9bcf63cbfe772245d7e4871","links":[],"anchors":{"digital-garden":{"type":"header","text":"Digital Garden","value":"digital-garden","line":8,"column":0,"depth":1}},"children":["zFMjbn3xihVNHjUIdZCD1","IK6NOKemuDjhfstJBovKL","RS8qp1GxwtiJopCUHTTtq","ZaTr28eWk1DrXOEsc1YVb","Vi0WYVLZunVM9iR8XZJn3","ngAbg7gluvbt1bY1UIRsi","RCPPXSakm5TvKka8kOmVp","MPx8ykTP57I40WTZvTP7f","ZU5WmdTG1bHoE8RcmZXZG","jqWiyYJff92RjXuUQt9PQ","KihijM8OQvZ4pASkkhqzL","F9vyqvls3OBCujtukqKhy","facc2b01-755a-409f-99f6-57bef2d1501f","m5ov42Vm6mR7RQWTvl1NW","YYt62mSW964cwb5nP0hva","PZxxZ4iESzSlbbHJKxuAZ","UDu62Pa6BaRqlG8uGoMhy","nMCtMXVvjBsJk3iw1zoIO","ANfx9Z4a6ZA0uJuSHtbIJ","BkG557LKUYbH1DnxprEVT","1TaH8zDTM98FZ9SYaeXLM","dc79799f-a55d-48ab-a8be-c48adb1b19c0","f6feef57-b8f5-451f-a09a-7b63f6a07183","4sz47Y0LKs1Si73rWtyyh","5a9fb1df-478e-4687-9be0-5cb97e61ec57","1374e9e9-1cbc-4e1f-b1ca-66b8569533dd","f529cc34-aba0-45ca-ad7e-02ddda318941","0zcauha3il2NqtxZazIo7","9bbd6f68-03b2-41f4-92e4-2ca313e8b450","5a2ab598-fa7e-4471-8bda-9f5831b679ae","uV6w4mZPoohWyZV4Xaad0","RgE0mZLaUjPftFPZsiAoe","mytCOts26Pidush65tdRW","fwUzxfLSPMH1eL8oBoLWx","TbW7PM9bg1y5TGkiWwQ8b","xiSIDeEtIc8X0lpUQlppI","0jxgntiLNHWFuCbzqtFGF","GkdMprLUe4QQULBxmGN6V","4SYc6v5hxY5g6Ip6kjpwO","fqVQpS9FBiXgKsZX3R3sJ","L5JUZlGAGvTxrsEBB7DY8","963c4b54-02bd-4943-a15f-52cf59ffd0f4","TeTedoeS2LdHPR632eCpM","e65188a1-177e-4ab2-99f9-75f85d537621","fajYnbVhCRDi74xn0H30R","bArGdGwqo3iFkyKMyE7qR","4Dcp7gbEVoLLgfu7bXFai","5d700782-fb81-416e-83f9-5dd88260e350","zubgzhNFE6KlTgXcjTz6O","8lpdfWa0cbSq1XJQbcYcY","17I8ZksXvqCH1mRtZDjHp","kF916Ow84qpJJeMRkWMIo","tMLkLcrIHHBz56xVmBLkP","CSePBQ6q7qhowKESqVwt7","laZ4OfLhZNK1Kuy6GaWUr","z5IJblOknQhMzZ5QZh4ye","N36FHxfxzwJfxDY3miWyX","3bb25f58-2b50-4fa3-af55-48ea9f88a081","aOqNcxZh8qN4MoBJcvGTc","u93Rz4fEWGu6VBR30Zraf","9hjMHnKvYT4jLKvuDSXaV","LgW7mTIALODoXc54B3p6S","UYPxfHBFWX7fb6hHU5bB6","qxSOd6SPN8qf9ZUojVFDX","WQoMTf6VXBaxCgksXAVsj","2Mw4XgfyCHXHNOX5yoCIY","UFrwsXzC1yr7Ge8FF8Vbo","a8edc4ac-028b-40ec-872a-e4a005b04b2a","0XJqmcdtcMZu66glBI5O8","lK8r8BXS4ThiUTe4xKIZe","93de42ca-53ea-460a-baa7-b9ec5c47cb1e","Rxs2jaGpdFzqYtP7lAJFJ","aO8W81Z0PyIb6Hs7nOHPW","I01hENHnh8Tqu3Ok8sLzG","evqsPNutOaZ8hcBCqxFQu","zhhxcjZUHdU8uRLwGb9Zh","G1aFACZB2ooWGMGwyd3ZW","YWy1C4tgoaCcw1m8JJsr7","Szj3o5iaNxPpesiCqwrbu","XhvCDW3fIw6h6MhY5ticq","Q70g7SusFZBQXzkuQifv4","AzfWDH3wp7jFpL2EYxBcW","y0fwpZ9qMqirsLiFyOciU","ZF8xj8wwDUqKlrwTrCFZ1","tAJvhqhdfyZZa87QHq1TU","4hRmipi8lxpBLyzWu5JVB","iTg0C7QjvnmqBZeEigJNs","3babc3d2-79ae-470a-9c06-ab8bba2e684e","bF3UsMFya3fMeXWDspVov","ULkfbL9WpktbVYnzhl6Jw","PpNOO8JYWe6dM8wruSa7x","di40pCxDn7IiqE8lFdD46","rmW0mkerqV35I8QPji6lM","3IFIK1ByzeIxZCByryGLN","iImkYAKfkw3beAl6pLbDn","tho65KN0ZpjQlVvP1fEzM","ecDe8DNWrkeQTwpTEvHje","Yqhdd9mSJGN7OJOeyoSD2","NEhsoOfR7J6o01ielAuUm","Ws5tah8tpeyn9tK8VBTg8","Bqpifx2HX3vjLhX9yvhTV","gWAg15uBJgkS2B0wcpMAa","l7V3v2ep1YdDCt7DOr7Ci","yM2PJBdqJnHpD63cPA6sW","qn0bre7eLbi3QMbCfWkUi","fSu0KxFL41IRouotqmbHs","0gtg24Mj1a1bQFPRGQNlO","7iQPBMltLPLbFEz2qbjPu","yoh4pwoXcfELInGKRdYf6","dCGCWXgAmiOZXbdULT1m6","jMavlje07sNa6hSEIE8WA","Xxm0JE4dKHxrQAaZfzvxD","PAEBZCyFBZJyR7OoMZ41E","PQ6km8RgRCuyICBPOYz8f","2bhftt8rGuxYu4pFgNqru","hjYIZpHQWuXfeEoGeJEKW","K2M9bQqVq2eQfm29eslKL","X8obW1iKwYsvNgKWGyCzy","yJwSC7hqYIezTFHf5i0Ev","c4Z7ETcOHUILRMH32Sfjw","qiR6dIu857b9M9kTqjOyK","8vflbCVkwZtYcqdDDTNAz","Ku1OgHMhELajzo61Gx7ye","LUrfhDWo8wuwZu7CN9TV8","osu6JGOnvXJ5gt3tpqWZY","1a6173cd-cf13-4b34-a522-8350bf9a364f","ZgCUp366YrF2Tyky2NT73","S2sBltrPfd8a7ICuD7CuH","oWCuBXOg6JWfZzjmKxmNl","jOmhZ8ovLYTPbpM1vqSDx","FraC6xzLy1ei91l1ICyc9","6ceBas2RE9Q4787GDngH7","734cd78d-0bc9-426b-803d-1efc84dfffe5","k4Bb09px6r0FxIRs49SXV","oaG3H1S9IUBO644nGZigu","Ka7agQJkUMRSWN0uFdkWK","si3z090WsiLasMhJBa1Az","ljKAVERmdEiKLK9hXGKBm","LIcuGYV0DDt1VWbvH6Sed","MgUSrpNCIwDOW4fX3vPOF","bZumdyapJ2H0wWWOmJ45i","QHXEIyeZGIGMVi5Q52UWI","i5Fya3Vzzm0rBT0ctByuo"],"parent":null,"data":{},"body":"\n# Digital Garden\n\nThis Wiki of Personal Information is organized according to domains and their\nsub-domains, along with specific implementation of those domains.\n\nFor instance, Git itself is a domain. Sub-domains of Git, would be `commit`,\n`tags`, `reflog` etc. implementations of each of those could be `cli`, `strat`\n(strategies), `inner` etc.\n\nThe goal of the wiki is to present data in a manner that is from the perspective\nof a querying user. Here, a user is a programmer wanting to get key information\nfrom a specific domain. For instance, if a user wants to use postgres functions\nand hasn't done them in a while, they should be able to query\n`postgres.functions` to see what information is available to them.\n\nThis wiki has been written with myself in mind. While learning each of these\ndomains, I have been sensitive to the \"aha\" moments and have noted down my\ninsights as they arose. I have refrained from capturing information that I\nconsidered obvious or otherwise non-beneficial to my own understanding.\n\nThe ability I hope to gain from this wiki is the ability to step away from any\ngiven domain for a long period of time, and be able to be passably useful for\nwhatever my goals are within a short period of time. Of course, this is all\nvague sounding, and really depends on the domain, along with the ends I am\ntrying to reach.\n\nTo achieve this, the system should be steadfast to:\n- be able to put information in relatively easily, without too much thought\n\trequired to make that determination.\n- be able to extract the information that we need, meaning there is a\n\thigh-degree in confidence in the location of the information. The idea is\n\tthat information loses a large amount of its value when it is unfindable.\n\tTherefore, a relatively strict ideology should be used when determining\n\twhere a piece of information belongs.\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":3,"useFMTitle":true,"useNoteTitleForLink":true,"noLegacyNoteRef":true,"mermaid":true,"useKatex":true,"dev":{"enablePreviewV2":true},"site":{"assetsPrefix":"/Digital-Garden","siteUrl":"https://tycholiz.github.io","copyAssets":true,"siteHierarchies":["root"],"siteRootDir":"docs","usePrettyRefs":true,"title":"Dendron","description":"Publishable tech notes","duplicateNoteBehavior":{"action":"useVault","payload":["tech"]},"siteLastModified":true,"gh_edit_branch":"main","usePrettyLinks":true,"siteNotesDir":"notes","siteFaviconPath":"favicon.ico","gh_edit_link":true,"gh_edit_link_text":"Edit this page on GitHub","gh_root":"docs/","gh_edit_view_mode":"edit","writeStubs":true,"siteIndex":"root"},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{}},"workspace":{"dendronVersion":"0.67.1","vaults":[{"fsPath":"../main/tech","name":"tech"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"enableUserTags":true,"enableHashTags":true},"usePrettyRefs":true}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"QyhBiiMo8hlLxdGY9WX7K"},"buildId":"s-Pdpb0Y8fVIEUakhzEMN","assetPrefix":"/Digital-Garden","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>